'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import React, { Component } from 'react';
import { Animated, PanResponder, Platform, StyleSheet, TouchableOpacity, View } from 'react-native';

import PropTypes from 'prop-types';

/**
 * react-native-swipeview
 * @author rishabhbhatia<rishabh.bhatia08@gmail.com>
 * SwipeView can be rendered individually or within a list by passing three child views.
 *
 * e.g.
  <SwipeView
		renderVisibleContent={() => <Text>Visible Row</Text>}
		renderLeftView={() => <Text>Left Row</Text>}
		renderRightView={() => <Text>Right Row</Text>}
 	/>
 */
export default class SwipeView extends Component {

	constructor(props) {
		var _this;

		_this = super(props);

		this.getPreviewAnimation = function (toValue, delay) {
			return Animated.timing(_this._translateX, { duration: _this.props.previewDuration, toValue, delay });
		};

		this.onContentLayout = function (e) {
			_this.setState({
				dimensionsSet: !_this.props.recalculateHiddenLayout,
				hiddenHeight: e.nativeEvent.layout.height,
				hiddenWidth: e.nativeEvent.layout.width
			});

			if (_this.props.previewSwipeDemo && !_this.ranPreview) {
				let { previewOpenValue } = _this.props;
				_this.ranPreview = true;

				_this.getPreviewAnimation(previewOpenValue, _this.props.previewOpenDelay).start(function (_) {
					_this.getPreviewAnimation(0, _this.props.previewCloseDelay).start();
				});
			};
		};

		this.handleOnMoveShouldSetPanResponder = function (e, gs) {
			const { dx } = gs;
			return Math.abs(dx) > _this.props.directionalDistanceChangeThreshold;
		};

		this.handlePanResponderMove = function (e, gestureState) {
			const { dx, dy } = gestureState;
			const absDx = Math.abs(dx);
			const absDy = Math.abs(dy);

			if (_this.horizontalSwipeGestureEnded) return;

			if (absDx > _this.props.directionalDistanceChangeThreshold) {

				if (_this.swipeInitialX === null) {
					_this.swipeInitialX = _this._translateX._value;
				}
				if (!_this.horizontalSwipeGestureBegan) {
					_this.horizontalSwipeGestureBegan = true;
					_this.props.swipeGestureBegan && _this.props.swipeGestureBegan();
				}

				let newDX = _this.swipeInitialX + dx;
				if (_this.props.disableSwipeToLeft && newDX < 0) {
					newDX = 0;
				}
				if (_this.props.disableSwipeToRight && newDX > 0) {
					newDX = 0;
				}

				_this._translateX.setValue(newDX);

				let toValue = 0;
				if (_this._translateX._value >= 0) {
					_this.setState(_extends({}, _this.state, {
						swipingLeft: false
					}));

					if (_this._translateX._value > _this.props.leftOpenValue * (_this.props.swipeToOpenPercent / 100)) {
						toValue = _this.props.leftOpenValue;
						_this.onSwipedRight(toValue);
					}
				} else {
					_this.setState(_extends({}, _this.state, {
						swipingLeft: true
					}));

					if (_this._translateX._value < _this.props.rightOpenValue * (_this.props.swipeToOpenPercent / 100)) {
						toValue = _this.props.rightOpenValue;
						_this.onSwipedLeft(toValue);
					};
				};
			};
		};

		this.handlePanResponderEnd = function (e, gestureState) {
			if (!_this.horizontalSwipeGestureEnded) _this.closeRow();
		};

		this.closeRow = function () {
			if (_this.rowItemJustSwiped) {
				_this.forceCloseRow();
			} else {
				_this.manuallySwipeView(0);
			};
		};

		this.forceCloseRow = function () {
			Animated.timing(_this._translateX, {
				duration: 0,
				toValue: 0
			}).start();
		};

		this.onSwipedLeft = function (toValue) {
			const { onSwipedLeft } = _this.props;

			_this.horizontalSwipeGestureEnded = true;
			_this.rowItemJustSwiped = true;

			_this.manuallySwipeView(toValue).then(function () {
				if (onSwipedLeft) onSwipedLeft();
				_this.closeRow();
			});
		};

		this.onSwipedRight = function (toValue) {
			const { onSwipedRight } = _this.props;

			_this.horizontalSwipeGestureEnded = true;
			_this.rowItemJustSwiped = true;

			_this.manuallySwipeView(toValue).then(function () {
				if (onSwipedRight) onSwipedRight();
				_this.closeRow();
			});
		};

		this.manuallySwipeView = function (toValue) {

			return new Promise(function (resolve, reject) {

				Animated.timing(_this._translateX, {
					duration: _this.props.swipeDuration,
					toValue
				}).start(function (_) {
					_this.swipeInitialX = null;
					_this.horizontalSwipeGestureBegan = false;
					_this.horizontalSwipeGestureEnded = false;

					resolve();
				});
			});
		};

		this.renderVisibleContent = function () {
			return _this.props.renderVisibleContent();
		};

		this.renderRowContent = function () {

			if (_this.state.dimensionsSet) {
				return React.createElement(
					Animated.View,
					_extends({}, _this._panResponder.panHandlers, {
						style: {
							transform: [{ translateX: _this._translateX }]
						}
					}),
					_this.renderVisibleContent()
				);
			} else {
				return React.createElement(
					Animated.View,
					_extends({}, _this._panResponder.panHandlers, {
						onLayout: function (e) {
							return _this.onContentLayout(e);
						},
						style: {
							transform: [{ translateX: _this._translateX }]
						}
					}),
					_this.renderVisibleContent()
				);
			};
		};

		this.horizontalSwipeGestureBegan = false;
		this.horizontalSwipeGestureEnded = false;
		this.rowItemJustSwiped = false;
		this.swipeInitialX = null;
		this.ranPreview = false;
		this.state = {
			dimensionsSet: false,
			hiddenHeight: 0,
			hiddenWidth: 0,
			swipingLeft: this.props.swipingLeft
		};
		this._translateX = new Animated.Value(0);
	}

	componentWillMount() {
		var _this2 = this;

		this._panResponder = PanResponder.create({
			onMoveShouldSetPanResponder: function (e, gs) {
				return _this2.handleOnMoveShouldSetPanResponder(e, gs);
			},
			onPanResponderMove: function (e, gs) {
				return _this2.handlePanResponderMove(e, gs);
			},
			onPanResponderRelease: function (e, gs) {
				return _this2.handlePanResponderEnd(e, gs);
			},
			onPanResponderTerminate: function (e, gs) {
				return _this2.handlePanResponderEnd(e, gs);
			},
			onShouldBlockNativeResponder: function (_) {
				return false;
			}
		});
	}

	render() {
		return React.createElement(
			View,
			null,
			React.createElement(
				View,
				{ style: [styles.hidden, {
						height: this.state.hiddenHeight,
						width: this.state.hiddenWidth
					}] },
				this.state.swipingLeft ? this.props.renderRightView && this.props.renderRightView() || null : this.props.renderLeftView && this.props.renderLeftView() || null
			),
			this.renderRowContent()
		);
	}
};

const styles = StyleSheet.create({
	hidden: {
		bottom: 0,
		left: 0,
		overflow: 'hidden',
		position: 'absolute',
		right: 0,
		top: 0
	}
});

SwipeView.propTypes = {
	/**
  * TranslateX: How much view opens from the left
  * when swiping left-to-right (positive number)
  */
	leftOpenValue: PropTypes.number,
	/**
  * TranslateX: How much view opens from the right
  * when swiping right-to-left (negative number)
  */
	rightOpenValue: PropTypes.number,
	/**
  * Duration of the slide out swipe animation
  */
	swipeDuration: PropTypes.number,
	/**
  * What % of the left/right openValue does the user need to swipe
  * past to trigger onSwipedLeft/onSwipedRight actions.
  */
	swipeToOpenPercent: PropTypes.number,
	/**
  * Disable ability to swipe view to left
  */
	disableSwipeToLeft: PropTypes.bool,
	/**
  * Disable ability to swipe view to right
  */
	disableSwipeToRight: PropTypes.bool,
	/**
  * Called when left swipe is compelted
  */
	onSwipedLeft: PropTypes.func,
	/**
  * Called when right swipe is compelted
  */
	onSwipedRight: PropTypes.func,
	/**
  * Should the view do a slide out preview to show that it is swipeable
  */
	previewSwipeDemo: PropTypes.bool,
	/**
  * Duration of the slide out preview animation
  */
	previewDuration: PropTypes.number,
	/**
  * TranslateX value for the slide out preview animation
  */
	previewOpenValue: PropTypes.number,
	/**
  * Delay before starting preview animation
  */
	previewOpenDelay: PropTypes.number,
	/**
  * Delay before closing preview animation
  */
	previewCloseDelay: PropTypes.number,
	/**
  * Should swiping initialize with right-to-left
  * This should be useful for swipe previews
  * ex: +ve previewOpenValue swipingLeft: false | -ve previewOpenValue swipingLeft: true
  */
	swipingLeft: PropTypes.bool,
	/**
  * Enable hidden row onLayout calculations to run always
  */
	recalculateHiddenLayout: PropTypes.bool,
	/**
  * Change the sensitivity of the row
  */
	directionalDistanceChangeThreshold: PropTypes.number,
	/**
  * Main Content view.
  */
	renderVisibleContent: PropTypes.func.isRequired,
	/**
  * Left view to render behind the right view.
  */
	renderLeftView: PropTypes.func,
	/**
  * Right view to render behind the item view.
  */
	renderRightView: PropTypes.func
};

SwipeView.defaultProps = {
	leftOpenValue: 0,
	rightOpenValue: 0,
	swipeDuration: 250,
	swipeToOpenPercent: 35,
	disableSwipeToLeft: false,
	disableSwipeToRight: false,
	previewSwipeDemo: false,
	previewDuration: 300,
	previewOpenValue: -60,
	previewOpenDelay: 350,
	previewCloseDelay: 300,
	swipingLeft: true,
	recalculateHiddenLayout: false,
	directionalDistanceChangeThreshold: 2
};